<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>PQ vs TreeSet 动画对比 | @zhuizi</title>
  <style>
    body { margin:0; background:#0f172a; color:#e2e8f0; font-family: system-ui; overflow:hidden; }
    canvas { display:block; }
    .panel { position:absolute; top:20px; left:20px; background:rgba(15,23,42,0.9); padding:15px; border-radius:12px; width:300px; }
    button { margin:5px; padding:8px 16px; background:#1d4ed8; color:white; border:none; border-radius:6px; cursor:pointer; }
    button:hover { background:#2563eb; }
    .stats { margin-top:10px; font-family: monospace; font-size:12px; }
    .title { text-align:center; margin:20px; font-size:24px; font-weight:bold; color:#60a5fa; }
  </style>
</head>
<body>
<div class="title">PriorityQueue vs TreeSet 实时对比 | @zhuizi</div>
<canvas id="canvas"></canvas>
<div class="panel">
  <button onclick="addRandom()">插入随机数</button>
  <button onclick="pq.poll(); render()">PQ poll()</button>
  <button onclick="ts.pollFirst(); render()">TS pollFirst()</button>
  <button onclick="reset()">重置</button>
  <div class="stats" id="stats"></div>
</div>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
canvas.width = window.innerWidth; canvas.height = window.innerHeight;

class PriorityQueue {
  constructor() { this.data = []; }
  offer(x) { this.data.push(x); this.siftUp(this.data.length-1); }
  poll() { if (!this.data.length) return null; const min = this.data[0]; this.data[0] = this.data.pop(); this.siftDown(0); return min; }
  siftUp(i) { while (i > 0) { let p = (i-1)>>1; if (this.data[p] <= this.data[i]) break; [this.data[p], this.data[i]] = [this.data[i], this.data[p]]; i = p; } }
  siftDown(i) { const n = this.data.length; while (true) { let l = 2*i+1, r = 2*i+2, s = i; if (l < n && this.data[l] < this.data[s]) s = l; if (r < n && this.data[r] < this.data[s]) s = r; if (s === i) break; [this.data[i], this.data[s]] = [this.data[s], this.data[i]]; i = s; } }
  peek() { return this.data[0]; }
  size() { return this.data.length; }
}

class TreeSet {
  constructor() { this.root = null; this.size = 0; }
  add(x) { if (this.contains(x)) return; this.root = this.insert(this.root, x); this.size++; }
  insert(node, x) {
    if (!node) return {val: x, left: null, right: null, color: 'red'};
    if (x < node.val) node.left = this.insert(node.left, x);
    else if (x > node.val) node.right = this.insert(node.right, x);
    return node;
  }
  pollFirst() { if (!this.root) return null; const min = this.findMin(this.root); this.size--; return min; }
  findMin(node) { return node.left ? this.findMin(node.left) : node.val; }
  contains(x) { return this._contains(this.root, x); }
  _contains(node, x) { if (!node) return false; if (x === node.val) return true; return x < node.val ? this._contains(node.left, x) : this._contains(node.right, x); }
}

const pq = new PriorityQueue();
const ts = new TreeSet();

function addRandom() {
  const val = Math.floor(Math.random() * 100);
  pq.offer(val);
  ts.add(val);
  render();
}

function reset() {
  pq.data = []; ts.root = null; ts.size = 0; render();
}

function drawPQ() {
  const centerX = canvas.width * 0.3;
  const centerY = canvas.height / 2;
  pq.data.forEach((val, i) => {
    const angle = (i / Math.max(pq.data.length, 1)) * Math.PI * 2;
    const r = 100 + (i % 4) * 40;
    const x = centerX + Math.cos(angle) * r;
    const y = centerY + Math.sin(angle) * r;
    ctx.fillStyle = i === 0 ? '#f59e0b' : '#3b82f6';
    ctx.beginPath(); ctx.arc(x, y, 20, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle = 'white'; ctx.font = '14px monospace'; ctx.textAlign = 'center';
    ctx.fillText(val, x, y + 5);
  });
  ctx.fillStyle = '#e2e8f0'; ctx.font = '20px bold'; ctx.textAlign = 'center';
  ctx.fillText('PriorityQueue (最小堆)', centerX, centerY - 180);
}

function drawTreeSet() {
  const centerX = canvas.width * 0.7;
  const centerY = canvas.height / 2;
  drawNode(ts.root, centerX, centerY - 100, 200);
  ctx.fillStyle = '#e2e8f0'; ctx.font = '20px bold'; ctx.textAlign = 'center';
  ctx.fillText('TreeSet (红黑树)', centerX, centerY - 180);
}

function drawNode(node, x, y, offset) {
  if (!node) return;
  ctx.fillStyle = '#ef4444';
  ctx.beginPath(); ctx.arc(x, y, 22, 0, Math.PI*2); ctx.fill();
  ctx.fillStyle = 'white'; ctx.font = '14px monospace'; ctx.textAlign = 'center';
  ctx.fillText(node.val, x, y + 5);

  if (node.left) {
    ctx.strokeStyle = '#64748b'; ctx.lineWidth = 2;
    ctx.beginPath(); ctx.moveTo(x, y); ctx.lineTo(x - offset, y + 80); ctx.stroke();
    drawNode(node.left, x - offset, y + 80, offset * 0.6);
  }
  if (node.right) {
    ctx.beginPath(); ctx.moveTo(x, y); ctx.lineTo(x + offset, y + 80); ctx.stroke();
    drawNode(node.right, x + offset, y + 80, offset * 0.6);
  }
}

function updateStats() {
  document.getElementById('stats').innerHTML = `
    PQ: ${pq.size()} 个，最小=${pq.peek() || '-'}<br>
    TS: ${ts.size} 个，最小=${ts.findMin(ts.root) || '-'}<br>
    内存: PQ ~${(pq.size()*4/1024).toFixed(1)}KB | TS ~${(ts.size*32/1024).toFixed(1)}KB
  `;
}

function render() {
  ctx.fillStyle = 'rgba(15,23,42,0.1)'; ctx.fillRect(0,0,canvas.width,canvas.height);
  drawPQ();
  drawTreeSet();
  updateStats();
  requestAnimationFrame(render);
}

render();
window.onresize = () => { canvas.width = window.innerWidth; canvas.height = window.innerHeight; render(); };
</script>
</body>
</html>
